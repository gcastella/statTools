% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/statTools_code_BIVAR.R
\name{bivarTable}
\alias{bivarTable}
\alias{bivarTable.default}
\alias{bivarTable.formula}
\title{bivarTable}
\usage{
bivarTable(X, ...)

\method{bivarTable}{default}(X, y = NULL, data = NULL,
  margin = getOption("margin"), rounding = getOption("rounding"),
  test = c("none", "parametric", "non-parametric", "both"),
  condense.binary.factors = getOption("condense.binary.factors"),
  drop.x = getOption("drop.x"), drop.y = getOption("drop.y"),
  fit.model = NULL, outcome = getOption("outcome"), FUN.model = NULL, ...)

\method{bivarTable}{formula}(X, data = NULL, margin = getOption("margin"),
  rounding = getOption("rounding"), test = c("none", "parametric",
  "non-parametric", "both"),
  condense.binary.factors = getOption("condense.binary.factors"),
  drop.x = getOption("drop.x"), drop.y = getOption("drop.y"),
  fit.model = NULL, outcome = getOption("outcome"), FUN.model = NULL, ...)
}
\arguments{
\item{X}{Fórmula només amb termes additius. Accepta AsIs class, punt (.) i restes.
La part esquerra defineix les columnes (variable amb els grups), la dreta 
les files (on veure diferències entre grups).}

\item{...}{Arguments extres per les funcions del paràmetre FUN.model. Per a especificar els
arguments extres d'una funció que s'aplica a un model, s'afegeix dintre dels ...
un  argument amb el nom del model corresponent, i que serà una llista on cada element
tingui per nom la funció de la qual es volen canviar els paràmetres, i contingui una 
altra llista amb els paràmetres modificats (tipus el paràmetre args de do.call()).}

\item{data}{D'on llegir les dades per interpretar les fórmules.}

\item{margin}{Valors 1 o 2. Perfils fila o columna a les taules de contingència, 
respectivament.}

\item{rounding}{Nombre de decimals a tenir en compte (els p-valors s'arrodoneixen amb un 
altre criteri).}

\item{test}{One of "both", "parametric", "non-parametric" or "none". Si volem que fagi uns 
testos predeterminats en concret (veure options()$parametric.tests i 
options()$non.parametric.tests).}

\item{condense.binary.factors}{Si transformar en una sola línia les variables binàries.}

\item{drop.x}{Refactoritzar les variables fila si són factors per treure nivells sense observacions.}

\item{drop.y}{Refactoritzar la variable columna (grups) per treure nivells sense observacions.}

\item{fit.model}{Llista amb noms de les fórmules a partir de les quals ajustar un model glm o lm
segons s'escaigui. L'ús del punt (.) s'utilitza per referir-se de forma general 
a la variable fila o columna sense haver d'especificar-ne el nom (veure update.formula).}

\item{outcome}{Valors 1 o 2, segons si pels models la variable considerada outcome seran les 
que estan a les files o a les columnes, respectivament.}

\item{FUN.model}{Funcions extres que s'aplicaran als models, els outputs de les quals s'afegiran 
com a noves columnes a la taula resultant. El primer paràmetre de les quals 
ha de ser el model. S'especifica com una llista on cada element s'anomena com un
dels models especificats a fit.model i serà un vector amb els noms de les funcions
(entrats com a string) a aplicar en cadascun dels respectius models. Funcions 
preparades: nagelkerke(), adjNagelkerke(), getPval(), getBetaSd(), getORCI(),
verticalgetPval(), verticalgetBetaSd(), verticalgetORCI(), GoF().}
}
\value{
A list with class bivarTable, where the first argument is the table generated (a matrix) and the other arguments
are input arguments returned as outputs in the list, such as margin, outcome, fit.model, FUN.model, test, drop.x,
drop.y, condense.binary.factors, data.frame with the values from variables in the rows (named X), and the same for
the columns (named y), and extra arguments in ..., with maybe, the arguments for calling the functions in FUN.model.
}
\description{
Creating a table with the results of assessing differences among groups.
}
\section{Methods (by class)}{
\itemize{
\item \code{default}: Calling separately a data frame with the variables in the rows and the grouping variable.

\item \code{formula}: Calling bivarTable using a formula.
}}
\examples{
iris$prova <- cut(iris$Sepal.Width + iris$Sepal.Length, breaks = 2)
iris$prova2 <- cut(iris$Sepal.Width + iris$Sepal.Length, breaks = 3)
iris$prova3 <- cut(iris$Sepal.Width + iris$Sepal.Length, breaks = 5)
bvt <- bivarTable(X = Species ~ . + I(Sepal.Width>3) - Sepal.Length, 
                  data = iris, 
                  margin = 2, 
                  outcome = 1, 
                  drop.x = TRUE, 
                  drop.y = TRUE, 
                  test = "non-par", 
                  condense.binary.factors = TRUE, 
                  rounding = 3,
                  fit.model = list(simple = ~ .,
                                   adj = ~ . + Sepal.Length), 
                  FUN.model = list(simple = c("getPval"), 
                                   adj = c("getORCI", "getPval")),
                  adj = list(getPval = list(vars = 4), 
                             getORCI = list(vars = 4)))
bvt
bvt <- bivarTable(X = I(Sepal.Width>3) ~ . - Sepal.Length,
                  data = iris, 
                  margin = 2, 
                  rounding = 3,
                  test = "both", 
                  condense.binary.factors = FALSE, 
                  drop.x = TRUE, 
                  drop.y = TRUE, 
                  fit.model = list(simple = ~ ., 
                                   adj = ~ . + Sepal.Length), 
                  outcome = 2, 
                  FUN.model = list(simple = c("getPval"), 
                                   adj = c("verticalgetORCI", 
                                           "verticalgetPval")))
bvt
\dontrun{
export(bvt)
}

}
\seealso{
\code{\link{export}}
}

